赫夫曼编码
变长编码：先统计各个字符出现的个数，出现的次数越多，给的编码越小. 但是某一个字符的编码可能是其他编码的前缀
赫夫曼编码： 
1. 先统计各个字符出现的个数
2. 按照上面的字符构建赫夫曼树，次数作为权值
3. 根据赫夫曼树，给各个字符编码，规定向左为0，向右为1

package com.zjx.huffmancode;

import java.util.*;

public class HuffmanCode {
    public static void main(String[] args) {
        String content = "i like like like java do you like a java";
        byte[] contentBytes = content.getBytes();

        List<Node> nodes = getNodes(contentBytes);
        System.out.println(nodes);

        System.out.println("赫夫曼树");
        Node huffmanTreeRoot = createHuffmanTree(nodes);
        preOrder(huffmanTreeRoot);

        //测试哈夫曼编码
//        getCode(huffmanTreeRoot, "", stringBuilder);
        getCodes(huffmanTreeRoot);
        System.out.println("生成的编码表" + huffmanCodes);

        byte[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);
        System.out.println(Arrays.toString(huffmanCodeBytes));
    }
    //用统计byte[]中每个byte出现的次数，然后将Map中的数字放到List里面
    private static List<Node> getNodes(byte[] bytes){
        //先创建ArrayList
        ArrayList<Node> nodes = new ArrayList<>();
        //存入每个byte出现的次数(map)
        Map<Byte, Integer> counts = new HashMap<>(); //注意，集合中只能用包装类
        for (byte b: bytes) {
            Integer count = counts.get(b);
            if (count == null) counts.put(b, 1);
            else counts.put(b, count + 1);
        }
        //将键值对转为Node对象，并加入到nodes集合
        //遍历map
        for (Map.Entry<Byte, Integer> entry: counts.entrySet()) {
            nodes.add(new Node(entry.getKey(), entry.getValue()));
        }
        return nodes;
    }
    //构建HuffmanTree
    private static Node createHuffmanTree(List<Node> nodes){
        while (nodes.size() > 1){
            Collections.sort(nodes);
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            //新二叉树的根节点没有data，只有weight
            Node parent = new Node(null, leftNode.weight + rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            nodes.add(parent);
        }
        return nodes.get(0);
    }
    //前序遍历
    private static void preOrder(Node root){
        if (root == null) System.out.println("无法遍历");
        else root.preOrder();
    }
    //将赫夫曼树转成赫夫曼表
    //1. 将赫夫曼编码放到Map<Byte, String>中
    static Map<Byte, String> huffmanCodes = new HashMap<>();
    //2. 在生成赫夫曼编码表时，拼接路径。定义一个StringBuilder来存叶子节点的路径
    static StringBuilder stringBuilder = new StringBuilder();

    //为了调用方便，重载方法
    private static Map<Byte, String> getCodes(Node root){
        if (root == null) return null;
        getCode(root.left, "0", stringBuilder);
        getCode(root.right, "1", stringBuilder);
        return huffmanCodes;
    }
    /**
     * 功能：将传入的node的所有叶子节点的哈夫曼编码放入到HuffmanCodes集合
     * @param node 传入的节点
     * @param code 路径：左子节点是0，右子节点是1
     * @param stringBuilder 用来拼接路径
     */
    private static void getCode(Node node, String code, StringBuilder stringBuilder){
        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
        stringBuilder2.append(code);
        if (node != null){
            //判断是不是叶子节点
            if (node.data == null){//非叶子节点
                //递归
                getCode(node.left, "0", stringBuilder2);
                getCode(node.right, "1", stringBuilder2);
            } else {
                //是叶子节点
                huffmanCodes.put(node.data, stringBuilder2.toString());
            }
        }
    }

    /**
     *
     * @param bytes 原始的字符串对应的byte[]
     * @param huffmanCodes 生成的赫夫曼编码map
     * @return 返回赫夫曼编码处理后的byte[]
     *  对于之前的String content = "i like like like java do you like a java"，会有一个编码
     *  然后将这个编码转成一个byte[]数组（每8位存一次） 其实存入的是一个补码
     *  因为之前的content长度只有40，而新生成的表很大，所以要压缩
     */
    //编写一个方法，将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码
    private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes){
        //先使用赫夫曼编码表，将byte转成赫夫曼编码对应的字符串
        StringBuilder stringBuilder = new StringBuilder();
        for(byte b : bytes){
            stringBuilder.append(huffmanCodes.get(b));
        }
//        System.out.println(stringBuilder.toString());
        //将“1010100010...”转成byte[]
        int len;
        if (stringBuilder.length() %8 == 0) len = stringBuilder.length() / 8;
        else len = stringBuilder.length() / 8 + 1;
        //用一句话代替上面的写法： int len = (stringBuilder.length() + 7) / 8;

        //创建存储压缩后byte数组
         byte[] huffmanCodeBytes =  new byte[len];
         int index = 0; //记录是第几个byte
        for (int i = 0; i < stringBuilder.length(); i += 8) {//因为每8位对应一个byte，所以步长+8
            String strByte;
            if (i + 8 > stringBuilder.length()){ //如果长度不够8位
                strByte = stringBuilder.substring(i);
            }else {
                strByte = stringBuilder.substring(i, i + 8);
            }
            //将strByte转成一个byte，放入到HuffmanCodeBytes
            huffmanCodeBytes[index] = (byte)Integer.parseInt(strByte,2);
            index++;
        }
        return huffmanCodeBytes;
    }

}

class Node implements Comparable<Node>{
    Byte data;
    int weight; //数据的出现次数
    Node left;
    Node right;

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        return this.weight - o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }
    //前序遍历
    public void preOrder(){
        System.out.println(this);
        if (this.left != null) this.left.preOrder();
        if (this.right != null) this.right.preOrder();
    }
}
