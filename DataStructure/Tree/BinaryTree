树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。
二叉树的子节点分为左节点和右节点。
如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。
如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。

前序：父 -> 左 -> 右
中序：左 -> 父 -> 右
后序：左 -> 右 -> 父

package com.zjx.tree;

public class BinaryTree {
    public static void main(String[] args) {
        //先创建二叉树
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");
        BinaryTreeDemo binaryTreeDemo = new BinaryTreeDemo(root);
        //先手动创建二叉树，之后递归创建二叉树
        root.setLeft(node2); //因为left是私有，因此不能用root.left = node2;
        root.setRight(node3);
        node3.setRight(node4);

        //测试
        System.out.println("前序遍历");
        binaryTreeDemo.preOrder();
        System.out.println("中序遍历");
        binaryTreeDemo.infixOrder();
        System.out.println("后序遍历");
        binaryTreeDemo.postOrder();


    }
}

//创建hero节点
class HeroNode{
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
    //前序遍历
    public void preOrder(){
        System.out.println(this); //先输出父节点
        //递归向左子树
        if (this.left != null) this.left.preOrder();
        //递归向右子树
        if (this.right != null) this.right.preOrder();
    }

    //中序遍历
    public void infixOrder(){
        //递归向左子树
        if (this.left != null) this.left.preOrder();
        System.out.println(this); //输出父节点
        //递归向右子树
        if (this.right != null) this.right.preOrder();
    }

    //后序遍历
    public void postOrder(){
        //递归向左子树
        if (this.left != null) this.left.preOrder();
        //递归向右子树
        if (this.right != null) this.right.preOrder();
        System.out.println(this); //输出父节点
    }
}

//创建二叉树
class BinaryTreeDemo{
    private HeroNode root;

    public BinaryTreeDemo(HeroNode root) {
        this.root = root;
    }


    //前序
    public void preOrder(){
        if (this.root != null){
            this.root.preOrder(); //这样调用之后，preOrder中的this就指向root，因为谁调用，this就指向谁
        }else {
            System.out.println("当前二叉树为空，无法遍历");
        }
    }

    //中序
    public void infixOrder(){
        if (this.root != null){
            this.root.infixOrder(); //这样调用之后，preOrder中的this就指向root，因为谁调用，this就指向谁
        }else {
            System.out.println("当前二叉树为空，无法遍历");
        }
    }

    //后序
    public void postOrder(){
        if (this.root != null){
            this.root.postOrder(); //这样调用之后，preOrder中的this就指向root，因为谁调用，this就指向谁
        }else {
            System.out.println("当前二叉树为空，无法遍历");
        }
    }
}


查找指定节点
使用前序、中序、后序来查询指定的节点
前序的思路： 
1. 先判断当前节点的no是否等于要查找的。如果相等，返回当前节点。如果不等，判断左子节点是否为空，不是空就递归。
2. 如果左递归找到，返回，否则右递归


